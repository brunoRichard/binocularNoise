---
title: "Neural responses to binocular correlated and anticorrelated noise stimuli"
author:
  - name: "Bruno Richard"
    email: "br379@newark.rutgers.edu"
    affil-id: 1
  - name: "Robert F. Hess"
    affil-id: 2
  - name: "Sing Ip Lee"
    affil-id: 3
  - name: "Daniela Marinova"
    affil-id: 3
  - name: "Daniel H. Baker"
    affil-id: 3
affiliations:
  - id: 1
    name: "Department of Mathematics and Computer Science, Rutgers University, Newark, New Jersey, USA"
  - id: 2
    name: "Department of Ophthalmology, McGill University, Montreal, Qc, Canada"
  - id: 3
    name: "Department of Psychology, University of York, York, UK"
    format: pdf

format:
  pdf:
    keep-tex: true
    template-partials:
      - title.tex   
      - keywords.tex
    geometry:
      - left=25mm
      - right=25mm
      - top=25mm
      - bottom=25mm
    fontsize: 12pt
    tbl-cap-location: bottom
    include-in-header:
      text: |
        \usepackage{indentfirst}
        \setlength{\parindent}{15pt}
        \setlength{\parskip}{10pt}
        \usepackage[font=small]{caption}  % Options: small, footnotesize, scriptsize, etc.
        \usepackage[noblocks]{authblk}
        \renewcommand*{\Authsep}{, }
        \renewcommand*{\Authand}{, }
        \renewcommand*{\Authands}{, }
        \renewcommand\Affilfont{\small}
        % Define a keywords command for inline keywords
        \newcommand{\printkeywords}[1]{\noindent\textbf{Keywords:} #1\par}

---

# Draft Abstract
*Introduction*
To integrate the inputs from the eyes into a single percept, the visual system is thought to encode monocular signals through summation and differencing channels. Here, we use 
Steady-State Visually Evoked Potentials (SSVEPs) to investigate the neural responses associated with summation and differencing mechanisms. 

*Description and results from experiment 1*
We measured responses to binocular noise stimuli with differing degrees of interocular correlation. Across the eyes, stimuli could oscillate at a frequency of 3Hz from (i) no correlation to perfect interocular correlation, (ii) no correlation to perfect interocular correlation with a disparity cue, (iii) from no correlation to perfect interocular anticorrelation (i.e., opposite interocular contrast), and (iv) a control condition with no interocular correlation. A total of 15 observers participated in the study. Responses to correlated stimuli showed a peak at the fundamental frequency (3Hz), while adding a disparity cue led to a response at the fundamental and its second harmonic (6Hz). We measured stereoacuity in our observers and found that thresholds correlated strongly with the SNRs of the fundamental frequency, but not with its second harmonic. Surprisingly, no steady-state responses were found for interocular anticorrelation; signal-to-noise ratios at 3Hz were no different from those of the control condition. 

*Description of a generic model*
We modelled our data using an image-based variant of the two-stage contrast gain control model of binocular summation. In this model, interocular correlation-dependent SSVEPs were generated from the responses of a bank of disparity-selective log-Gabor filters. The monocular filter responses were fed through a nonlinearity and contrast gain control, followed by binocular summation and binocular difference. The binocular sum and difference responses were fed through a second nonlinearity and binocular contrast gain control, with the output Fourier-transformed to generate model SSVEPs. 

*Conclusion*
Neural responses to interocular correlation were measurable using SSVEP methods, yet responses to anticorrelation (differences) were not. 


```{r, preliminaries, echo = FALSE, warning=FALSE, message=FALSE }
packagelist <- c('R.matlab','pracma','EnvStats', "matlab")

missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

posterColours <- c("#333E47", "#6a757c", "#e31936")
posterColoursRamped <- colorRampPalette(posterColours, space = "Lab", interpolate = "spline")(8)
categoricalPalette <- c("#333E47","#3B5C62","#777079", "#4A6F74","#B94256", "#5E767B", "#955F6D", "#E31835")

```


```{r, dataload,  echo = FALSE}
theCompleteParticipants <- c("001", "002", "003", "004", "007", "008", "009", "010", "011", "012", "013", "014", "015")

currentDirectory <- getwd()
processedEEGdir <- paste0(currentDirectory, "/Processed Data/Experiment 1/")

theParticipantFiles <- list.files(processedEEGdir, pattern = paste0(theCompleteParticipants, collapse = "|"))
allPConditionData <- array(NA, dim = c(200,13,length(theParticipantFiles)))

for (P in 1:length(theParticipantFiles)){
  load(paste0(currentDirectory, "/Processed Data/Experiment 1/", theParticipantFiles[P]))
  allPConditionData[,,P] <- avgSNRCondition2
}

allPConditionData[1,,] <- 1

pAveragedSNRLog <- apply(allPConditionData, c(1,2), median, na.rm = TRUE)
noiseConditionsAvg <- pAveragedSNRLog[,c(1:3, 13)]
noiseConditionsIndv <- allPConditionData[, c(1:3, 13), ]
pAveragedSNRLog <- apply(allPConditionData, c(1,2), median, na.rm = TRUE)

theFs <- c(31, 61, 91, 121, 151, 181)
conditions <- c("Correlated Noise", "Correlated Noise\nWith Stereo Cue", "Anticorrelated Noise", "Control")
```

### Median SNRs

```{r, fig.width=8, echo = FALSE}
par(mfcol = c(1,4), pty = "s", mai = c(.1,.2,.1,.1), omi = c(.25,.4,.1,.1))
noiseConditionsAvg[1:10,] <-1

for (i in 1:4){
  plot(x = NULL, y = NULL, ylim = c(0,6), xlim = c(0,210), axes = FALSE, ann = FALSE)
  axis(1,  at = c(0,3,6,9,12,15,18,21)*10+1, tck = -.015, lwd = 2, labels = FALSE)
  axis(2,  at = pretty(c(0,6)), tck = -.015, lwd = 2, labels = FALSE)
  
  mtext(c(0,3,6,9,12,15,18,21), 1, at = c(0,3,6,9,12,15,18,21)*10+1, line = .6)
  mtext("Frequency (Hz)", 1, font = 2, line = 2)
  if (i == 1) {
    mtext(pretty(c(0,6)), 2, at = pretty(c(0,6)), line = .6, las = 1)
    mtext("SNR", 2, font = 2, line = 2 )
  }
  mtext(conditions[i], 3, font = 2)
  
  abline(h = 1, lwd = 2, col = posterColours[2])
  abline(v = theFs, lty = 2, col = posterColours[2])
  
  lines(1:200, noiseConditionsAvg[,i], lwd = 3, col = posterColours[1])
}
```

### Condition Comparisons

```{r, Correlated Noise to Control, echo = FALSE, fig.width=10}
par(mfcol = c(1,3), mai = c(.1,.1,.1,.1), omi = c(.4,.5,.4,.1))
realMedianDiff <- noiseConditionsAvg[31,1] - noiseConditionsAvg[31,4]
nPerm <- 1000

subset <- c(noiseConditionsIndv[31,c(1,4),])
medianDiff <- NULL
for (i in 1:nPerm){
  IDX1 <- sample(1:length(subset), length(subset)/2, replace = FALSE)
  IDX2 <- setdiff(1:length(subset), IDX1)
  medianDiff[i] <- median(subset[IDX1]) - median(subset[IDX2])
}
pValue <- mean(abs(medianDiff) > realMedianDiff)

axisValues <- hist(medianDiff, plot = FALSE)
xLimit <- range(axisValues$breaks)
yLimit <- range(pretty(range(axisValues$counts)))

hist(medianDiff, axes = FALSE, ann = FALSE, xlim =xLimit, ylim = yLimit, col = posterColours[1], border = "white")
abline(v = c(-realMedianDiff, realMedianDiff), lwd = 2,col = posterColours[3], lty = 2)
axis(1, at = axisValues$breaks, tck = -.015, labels = FALSE, lwd = 2)
axis(2, at = pretty(yLimit), tck = -.015, labels = FALSE, lwd = 2)
mtext(axisValues$breaks,1, at = axisValues$breaks, line = .5, cex = .8)
mtext(pretty(yLimit)/nPerm,2,at =pretty(yLimit), las = 1, line = .5, cex = .8)
mtext("Median Difference", 1, font = 2, line = 2)
mtext("Proportion of Scores", 2, font = 2, line = 3)
mtext(paste0("1F Median Difference = ", round(realMedianDiff, 2), ", p = ", round(pValue,3)), 3, font = 1, adj = 0, cex = .8, line = -0.5)
mtext("Correlated Noise VS Control", 3, line = 1, font = 2)

# Stereo to control

realMedianDiff <- noiseConditionsAvg[31,2] - noiseConditionsAvg[31,4]
nPerm <- 1000

subset <- c(noiseConditionsIndv[31,c(2,4),])
medianDiff <- NULL
for (i in 1:nPerm){
  IDX1 <- sample(1:length(subset), length(subset)/2, replace = FALSE)
  IDX2 <- setdiff(1:length(subset), IDX1)
  medianDiff[i] <- median(subset[IDX1]) - median(subset[IDX2])
}
pValue <- mean(abs(medianDiff) > realMedianDiff)

axisValues <- hist(medianDiff, plot = FALSE)
xLimit <- range(axisValues$breaks)

hist(medianDiff, axes = FALSE, ann = FALSE, xlim =xLimit, ylim = yLimit, col = posterColours[1], border = "white")
abline(v = c(-realMedianDiff, realMedianDiff), lwd = 2,col = posterColours[3], lty = 2)
axis(1, at = axisValues$breaks, tck = -.015, labels = FALSE, lwd = 2)
axis(2, at = pretty(yLimit), tck = -.015, labels = FALSE, lwd = 2)
mtext(axisValues$breaks,1, at = axisValues$breaks, line = .5, cex = .8)
mtext("Median Difference", 1, font = 2, line = 2)
mtext(paste0("1F Median Difference = ", round(realMedianDiff, 2), ", p = ", round(pValue,3)), 3, font = 1, adj = 0, cex = .8, line = -0.5)
mtext("Stereo VS Control", 3, line = 1, font = 2)

# Anti-correlated to control

realMedianDiff <- noiseConditionsAvg[31,3] - noiseConditionsAvg[31,4]
nPerm <- 1000

subset <- c(noiseConditionsIndv[31,c(3,4),])
medianDiff <- NULL
for (i in 1:nPerm){
  IDX1 <- sample(1:length(subset), length(subset)/2, replace = FALSE)
  IDX2 <- setdiff(1:length(subset), IDX1)
  medianDiff[i] <- median(subset[IDX1]) - median(subset[IDX2])
}
pValue <- mean(abs(medianDiff) > realMedianDiff)

axisValues <- hist(medianDiff, plot = FALSE)
xLimit <- range(axisValues$breaks)

hist(medianDiff, axes = FALSE, ann = FALSE, xlim =xLimit, ylim = yLimit, col = posterColours[1], border = "white")
abline(v = c(-realMedianDiff, realMedianDiff), lwd = 2,col = posterColours[3], lty = 2)
axis(1, at = axisValues$breaks, tck = -.015, labels = FALSE, lwd = 2)
axis(2, at = pretty(yLimit), tck = -.015, labels = FALSE, lwd = 2)
mtext(axisValues$breaks,1, at = axisValues$breaks, line = .5, cex = .8)
mtext("Median Difference", 1, font = 2, line = 2)
# mtext("Proportion of Scores", 2, font = 2, line = 3)
mtext(paste0("1F Median Difference = ", round(realMedianDiff, 2), ", p = ", round(pValue,3)), 3, font = 1, adj = 0, cex = .8, line = -0.5)
mtext("Anticorrelated Noise VS Control", 3, line = 1, font = 2)

```

```{r, get behaviour data, echo = FALSE}
behaviourDatadir <- paste0(currentDirectory, "/Behaviour Data/")

correct <- NULL
levels <- NULL
reversals <- NULL

threshold <- matrix(NA, nrow = 6, ncol = length(theCompleteParticipants))

for (p in 1:length(theCompleteParticipants)){
  dataTemp <- readMat(paste0(behaviourDatadir,theCompleteParticipants[p],'/',paste0(theCompleteParticipants[p], "Final.mat")))
  
  correct <- NULL
  levels <- NULL
  reversals <- NULL
  block <- NULL
  
  for (i in 1:6){
    correct <- c(correct, dataTemp$Exp[,,1]$Staircase[,,i]$response)
    levels <- c(levels, round(dataTemp$Exp[,,1]$Staircase[,,i]$x,2))
    reversals <- c(reversals, dataTemp$Exp[,,1]$Staircase[,,i]$reversal)
    block <- c(block, rep(i, length(dataTemp$Exp[,,1]$Staircase[,,i]$reversal)))
  }
  
  theVariableName <- paste0("allStaircases", p)
  assign(theVariableName, data.frame(participant=theCompleteParticipants[p], block = block, correct = correct, levels = levels, reversals = reversals))
  
  threshold[,p] <- dataTemp$Exp[,,1]$MeanReversalThreshold
}

allStaircases <- rbind(allStaircases1, allStaircases2,allStaircases3,allStaircases4,allStaircases5,allStaircases6,allStaircases7,allStaircases8,allStaircases9,allStaircases10,allStaircases11,allStaircases12,allStaircases13)
remove(allStaircases1,allStaircases2,allStaircases3,allStaircases4,allStaircases5,allStaircases6,allStaircases7,allStaircases8,allStaircases9,allStaircases10,allStaircases11,allStaircases12,allStaircases13)
```

```{r, echo = FALSE}
psychometricData <- aggregate(correct ~ levels + participant, data = allStaircases, FUN = mean)
psychometricData.SD <- aggregate(correct ~ levels + participant, data = allStaircases, FUN = sd)
staircaseThresholds <- aggregate(levels ~ participant, data = allStaircases, FUN = geomean, subset = reversals %in% c(12,11,10,9,8))
```

### Correlation between SNRs and Stereothresholds

```{r, fig.width=10,fig.height=5, echo = FALSE}
pixperdeg <- 36.73247
theConditions <- 1:3
thers <- matrix(NA, nrow = length(theFs), ncol = 3)
therps <- thers
par(mfcol = c(2,3), mai = c(0.25,0.25,0.1,0.1), omi = c(.25,.4,.25,0))

xRange <- range(pretty(range(noiseConditionsIndv[theFs,theConditions,])))
yRange <- range(pretty(range(pretty(range(staircaseThresholds$levels/pixperdeg*3600)))))
for (C in theConditions){
  count <- 0
  for (F in theFs[1:2]){
    count <- count+1
    plot(x = NULL, y = NULL, xlim = xRange, ylim = yRange, axes=FALSE, ann = FALSE)
    axis(1, at = pretty(xRange), lwd = 2, tck = -.015, labels = FALSE)
    axis(2, at = pretty(yRange), lwd = 2, tck = -.015, labels = FALSE)
    if (F == 61){
      mtext(pretty(xRange),1, at =pretty(xRange), line = .5)
      mtext("SNR", 1, font = 2, line = 2)
    }
    if (C == 1){
      mtext(pretty(yRange),2, at =pretty(yRange), line = .5, las = 2)
      mtext("Stereo Threshold\n(arc sec)", 2, font = 2, line = 2)
    }
    
    mod <- lm(staircaseThresholds$levels/pixperdeg*3600 ~ noiseConditionsIndv[F,C,])
    abline(mod, col = posterColours[2], lwd = 2)
    points(noiseConditionsIndv[F,C,],staircaseThresholds$levels/pixperdeg*3600, pch = 19, col = posterColours[1], cex = 1.5)
    out <- cor.test(noiseConditionsIndv[F,C,],staircaseThresholds$levels/pixperdeg*3600)
    thers[count,C] <- out$estimate
    therps[count,C] <- out$p.value
    
    legend("topright", legend = paste0("r = ", round(thers[count,C],3), ", p = ", round(therps[count,C],3)), bty = "n", inset = c(0,.05))
    if (F == theFs[1]){
        mtext(conditions[C], 3, font = 2, padj = 0.5, line = 1)
    }
    mtext(paste0((F-1)/10, "Hz"), 1, line = -1, font = 2, adj = 0, at = 0)
  }
}
```

### "Model" Responses

```{r,echo = FALSE, fig.width=10}
load(paste0(currentDirectory,"/", "baseModelResponses.RData"))
par(mfcol = c(1,3), mai = c(.1,.3,.1,.25), omi = c(.4,.3,.4,.1))

fft.Correlated <- abs(fft(sumResp+diffResp)[2:31])/1000

yLimit <- range(pretty(range(fft.Correlated)))
plot(x = NULL, y = NULL, xlim = c(0,30), ylim = yLimit, axes = FALSE, ann = FALSE)
axis(1, at = seq(0,30,3), tck = -.015, lwd = 2, labels = FALSE)
axis(2, at = pretty(yLimit), tck = -.015, lwd = 2, labels = FALSE)
mtext(seq(0,30,3), 1, at=seq(0,30,3), line = .5)
mtext(pretty(yLimit), 2, las = 1, at = pretty(yLimit), line = .5)
mtext("Frequency (Hz)", 1, font = 2, line = 2)
mtext("Response Magnitude",2, font = 2, line = 2.5)
for (i in 1:30){
  lines(c(i,i), c(0,fft.Correlated[i]), lwd = 2, col = posterColours[1])
}
points(seq(3,30,3),fft.Correlated[seq(3,30,3)], pch = 19, col = posterColours[1], cex = 1.5)
mtext("Correlated Noise", 3, font = 2)
####

fft.Stereo <- abs(fft(sumResp.stereo+diffResp.stereo)[2:31])/1000

yLimit <- range(pretty(range(fft.Stereo)))
plot(x = NULL, y = NULL, xlim = c(0,30), ylim = yLimit, axes = FALSE, ann = FALSE)
axis(1, at = seq(0,30,3), tck = -.015, lwd = 2, labels = FALSE)
axis(2, at = pretty(yLimit), tck = -.015, lwd = 2, labels = FALSE)
mtext(seq(0,30,3), 1, at=seq(0,30,3), line = .5)
mtext(pretty(yLimit), 2, las = 1, at = pretty(yLimit), line = .5)
mtext("Frequency (Hz)", 1, font = 2, line = 2)
mtext("Response Magnitude",2, font = 2, line = 2.5)
for (i in 1:30){
  lines(c(i,i), c(0,fft.Stereo[i]), lwd = 2, col = posterColours[1])
}
points(seq(3,30,3),fft.Stereo[seq(3,30,3)], pch = 19, col = posterColours[1], cex = 1.5)
mtext("Correlated Noise + Stereo", 3, font = 2)

###

fft.Anti <- abs(fft(sumResp.anti+diffResp.anti)[2:31])/100000000

yLimit <- range(pretty(range(fft.Anti)))
plot(x = NULL, y = NULL, xlim = c(0,30), ylim = yLimit, axes = FALSE, ann = FALSE)
axis(1, at = seq(0,30,3), tck = -.015, lwd = 2, labels = FALSE)
axis(2, at = pretty(yLimit), tck = -.015, lwd = 2, labels = FALSE)
mtext(seq(0,30,3), 1, at=seq(0,30,3), line = .5)
mtext(pretty(yLimit), 2, las = 1, at = pretty(yLimit), line = .5)
mtext("Frequency (Hz)", 1, font = 2, line = 2)
mtext("Response Magnitude",2, font = 2, line = 2.5)
for (i in 1:30){
  lines(c(i,i), c(0,fft.Anti[i]), lwd = 2, col = posterColours[1])
}
points(seq(3,30,3),fft.Anti[seq(3,30,3)], pch = 19, col = posterColours[1], cex = 1.5)
mtext("Anticorrelated Noise", 3, font = 2)

```

