function [P] = d_probit(data, guessrate, showGra, showRes)% matlab implementation of probit analysis of staircase data% based on RJS_CURVE_FUNC delphi program, by RJS, TSM etc.% converted 19/02/05 by DHB% data is equivalent to x,r,n where x is the stimulus level, r is number correct and n is number of trials% inputs are:   'data' - an nX3 matrix where n is the number of stimulus levels and column 1 is the stimulus level, column 2 is the number of correct trials and column 3 is the total number of trials% 				'guessrate' - 50 for 2AFC, 33.3333 for 3AFC, 0 for yes/no%				'showGra' - do you want a graph displayed? - 0 for no, 1 for yes%				'showRes' - if '1', a results table is sent to the command window, if '0' it isn't% output is a matlab data structure P.field, with fields:%	P.noResult       = set to 1 if something has gone wrong%	P.BigC           = something to do with the guess rate% 	P.sigma          = ??% 	P.xBar           = mean of something% 	P.yBar           = mean of something% 	P.BigB           = ??% 	P.varB           = ??% 	P.varYBar        = ??% 	P.P50            = threshold at 75% correct on the probit curve for 2AFC% 	P.seP50          = S.E. of P50% 	P.P75            = threshold at 87.5% correct  (for 2AFC)% 	P.P84            = threshold at 92% correct (for 2AFC)% 	P.jnd75          = just noticeable difference?% 	P.chiSq          = chi square statistic (measures goodness of fit of regression)% 	P.df             = degrees of freedom% 	P.iterationCount = number of iterations% 	P.statReport     = now unused?% 	P.reportString   = if an error has occurred, it is reported hereglobal p_fiddle TOLA TOLB VERYSMALLNR BIGESCAPE MAXCOUNT showGraph showResults chSqTable NOOF_DF dfTableshowGraph = showGra;		% these are here to stop Matlab being annoying about global variablesshowResults = showRes;x = 1;r = 2;n = 3;% the record probitParams_t is now a structure called P  chSqTable(1,:)  =  		    [  1.642  3.219  4.642  5.989  7.289...                                   8.558  9.803 11.030 12.242 13.442...                                   14.631 15.812 16.985 18.151 19.311...                                   20.465 21.615 22.760 23.900 25.038...                                   26.171 27.301 28.429 29.553 30.675...                                   31.795 32.912 34.027 35.139 36.250...                                   47.269 58.164 68.972 79.715 90.405...                                  101.054 111.667];  chSqTable(2,:)  =             [  2.706  4.605  6.251  7.779  9.236...                                   10.645 12.072 13.362 14.684 15.987...                                   17.275 18.549 19.812 21.064 22.307...                                   23.542 24.769 25.989 27.204 28.412...                                   29.615 30.813 32.007 33.196 34.382...                                   35.563 36.741 37.916 39.088 40.256...                                   51.805 63.167 74.397 85.527 96.578...                                  107.565  118.498]; chSqTable(3,:)  =               [  3.841  5.991  7.815  9.488 11.071...                                   12.593 14.067 15.507 16.919 18.307...                                   19.675 21.026 22.362 23.685 24.996...                                   26.296 27.587 28.869 30.144 31.410...                                   32.671 33.924 35.173 36.415 37.653...                                   38.885 40.113 41.337 42.557 43.773...                                   55.759 67.505 79.082 90.531 101.879...                                  113.145 124.342]; chSqTable(4,:)  =               [  6.635  9.210 11.345 13.277 15.086...                                   16.812 18.475 20.090 21.666 23.209...                                   24.725 26.217 27.688 29.141 30.578...                                   32.000 33.409 34.805 36.191 37.566...                                   38.932 40.289 41.638 42.980 44.314...                                   45.642 46.963 48.278 49.588 50.892...                                   63.691 76.154 88.379 100.425 112.329...                                  124.116 135.807];  dfTable =                    [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 40 50 60 70 80 90 100];								  								  p_fiddle              =       0.001;  TOLA                  =       0.0001;  TOLB                  =       0.0001;  VERYSMALLNR           =       0.0001;  BIGESCAPE             =       1000;  MAXCOUNT              =       2000;  NOOF_DF			    =		37;  g = guessrate/100;if g > 0.5, g = 0.5; endP.noResult       = 0;P.BigC           = g;P.sigma          = -999;P.xBar           = 0;P.yBar           = 0;P.BigB           = 0;P.varB           = 0;P.varYBar        = 0;P.P50            = 0;P.seP50          = 0;P.P75            = 0;P.P84            = 0;P.jnd75          = 0;P.chiSq          = 999;P.df             = 999;P.iterationCount = 0;P.statReport     = 'No Stat Report.';P.reportString   = ' ';[nLevels, ndims]  = size(data);if nLevels < 2	errorTrap(2);	returnendif ndims ~= 3	errorTrap(9);	returnenddata = sortrows(data, 1);littleX = data(:,x);		for level = 1:nLevels				if data(level,n) <= 0			errorTrap(7);			return		end	nCorrect = data(level,r);		if data(level,n)==data(level,r)			nCorrect = (1-p_fiddle)*data(level,n);  %fiddle to nearly 100% correct		end		if data(level,r)==0			nCorrect = p_fiddle * data(level,n);  % fiddle to nearly 0%		end		littleP(level) = ((nCorrect/data(level,n)) - g)/(1 - g);		if littleP(level)==0			% the proportion correct is exactly equal to the guess rate...}			littleP(level) = (p_fiddle) - 2*p_fiddle*(rand * 2);		end			littleY(level) = NDE(littleP(level));			littleW(level) = 1;	end			%{* fit provisional regression line. *}		[P] = regress(nLevels, data(:,n), littleW, littleX, littleY, P);				condition = 0;	while condition==0						P.B0    = P.BigB;			P.yBar0 = P.yBar;			for level = 1:nLevels 				P.BigY        = P.yBar + P.BigB * (littleX(level) - P.xBar);  %{ Expected probit. }				exponential = (-P.BigY * P.BigY/2);								if exponential > 88  % {The limits were derived empirically}					if P.noResult==0, P.reportString = 'Could not perform exponential to calculate BigB.';   %						P.noResult  = 1;						P.BigZ      = 999;						P.BigY      = 99;					end				elseif exponential < -11356					if P.noResult==0, P.reportString = 'Could not perform exponential to calculate BigB.';   %						P.noResult  = 1;						P.BigZ      = 999;						P.BigY      = 99;					end				else					P.BigZ = exp(exponential)/(sqrt(2*pi));				end							if P.BigZ==0, P.BigZ = VERYSMALLNR;     end     % { Fudge factor. }				P.BigP   = NPR(P.BigY);				if P.BigP < VERYSMALLNR, P.BigP = VERYSMALLNR; end % {fudge factor. }										if P.BigP > (1 - VERYSMALLNR), P.BigP = 1 - VERYSMALLNR; end				P.pDenom = ((P.BigP + (P.BigC/(1-P.BigC))) * (1 - P.BigP));						if P.pDenom==0							errorTrap(5);							return						end				littleW(level) = P.BigZ * P.BigZ/((P.BigP + (P.BigC/(1-P.BigC))) * (1 - P.BigP));				littleY(level) = P.BigY + (littleP(level) - P.BigP)/P.BigZ; %{Working probit}						end  % the for loop						[P] = regress(nLevels, data(:,n), littleW, littleX, littleY, P);		P.iterationCount = P.iterationCount + 1;								if abs(P.yBar0 - P.yBar) < TOLA, condition = 1; end			% these are the real conditions which control the loop			if abs(P.B0 - P.BigB) < TOLB, condition = 1; end			if abs(P.BigB) > BIGESCAPE, condition = 1; end			if P.iterationCount > MAXCOUNT, condition = 1; end						end   % end of while loop							if abs(P.BigB) > BIGESCAPE					P.reportString = 'BIG ESCAPE in probit analyses.';					P.noResult  = 1;				end								if P.iterationCount > MAXCOUNT					P.reportString = 'Iterations exceeded maximum.'; 					P.noResult = 1;				end									if P.BigB==0					P.reportString = 'bigB = 0 in probit analyses.';					P.noResult  = 1;													P.P50          = 0;					P.varP50       = 0;					P.P75          = 0;					P.P84          = 0;					P.sigma        = 0; 			    				else       %{** Set the PROBIT PARAMS **}				P.P50    = -P.yBar/P.BigB + P.xBar;				P.varP50 = (P.varYBar + (P.P50 - P.xBar)*(P.P50 - P.xBar) * P.varB)/(P.BigB*P.BigB);					if P.varP50 < 0,					errorTrap(5);					return					end				P.jnd75  = NDE(0.75)/P.BigB;				P.sigma  = NDE(0.84)/P.BigB;				P.P84    = P.P50 + P.sigma;				P.P75    = P.P50 + P.jnd75;											end   											   P.seP50 = sqrt(abs(P.varP50));   if P.noResult==0, [P] = doChiSqForProbit(data(:,x),data(:,n),data(:,r),P); end   if showResults==1    disp('');	    if P.noResult==1	     disp('Probit analyses failed.');	     disp(P.reportString);	    end    disp(strcat('P50   = ', num2str(P.P50)));    disp(strcat('SEP50 = ', num2str(P.seP50)));    disp(strcat('P75   = ', num2str(P.P75)));    disp(strcat('JND75 = ', num2str(P.jnd75)));    disp(strcat('P84   = ', num2str(P.P84)));    disp(strcat('Sigma = ', num2str(P.sigma)));    disp(strcat('xBar  = ', num2str(P.xBar)));    disp(strcat('yBar  = ', num2str(P.yBar)));    disp(strcat('ChiSq = ', num2str(P.chiSq)));    disp(strcat('df    = ', num2str(P.df)));    disp(P.statReport);    end %{showResults} if showGraph==1   for i = 1:nLevels    percentCorrect(i) = data(i,r)/(data(i,n)/100);   plotProbitGraph(nLevels, data(:,x), percentCorrect, P);  end end						%--------------------------------------------------------------------------------------------------						function errorTrap(errorNumber)disp(' ************************');disp('  ERROR : d_probit.m');disp(' ************************');disp(' ');  switch errorNumber    case 1        disp('probit_fit()');        disp('nw = 0 in sub-routine "regress".');    case 2        disp('probit_fit()');        disp('Number of levels for the experimental variable must be ');        disp('greater than one.');    case 3        disp('probit_fit()');        disp('The guess rate must not be greater than 50%');    case 4        disp('probit_fit()');        disp('x1 = 0 in sub-routine "regress".');    case 5        disp('probit_fit()');        disp('pDenom = 0');    case 6        disp('probit_fit()');        disp('varP50 < 0');	case 7        disp('probit_fit()');        disp('The n array must not contain values that are <= 0 between');        disp('n[1] and n[x[0]]');    case 8        disp('chiSquare()');        disp('Number of degrees of freedom cannot be less than 1');    case 9        disp('chiSquare()');        disp('Data is in incorrect format, must be LEVEL:NO CORRECT:NO OF TRIALS');	endreturn%-------------------------------------------------------------------------------------------------- function out = NDE(p)  if p > 0.5, p9 = 1-p;	  else p9 = p; end  if p < -0.5, p9 = -1-p; end  Y = sqrt(log(1/(p9*p9)));	  num = ((-0.000045364221015 * Y - 0.02042312102) * Y - 0.3422420885);  num = ((num * Y - 1) * Y - 0.3222324311);  denom = ((Y * 0.003856070063 + 0.10353775285) * Y + 0.5311034624);  denom = ((denom * Y + 0.5885815705) * Y + 0.0993484626);  xp = Y + num/denom;  out = xp;    if p < 0.5 	  if p > -0.5   out = -xp; endendreturn%--------------------------------------------------------------------------------------------------function [P] = regress(nLevels, n, w, x, y, P)    P.BigB    = 0;   P.varB    = 0;   P.xBar    = 0;   P.yBar    = 0;   P.varYBar = 0;   x1 = 0;   x2 = 0;   nw = 0;%{* Calc. xBar, yBar. *}   for level = 1:nLevels    P.xBar = P.xBar + w(level) * x(level) * n(level);    P.yBar = P.yBar + w(level) * y(level) * n(level);    nw   = nw   + w(level) * n(level);   end   if nw==0    errorTrap(1);    return   end   P.xBar = P.xBar/nw;   P.yBar = P.yBar/nw;   for level = 1:nLevels    x2 = x2 + w(level) * n(level) * (x(level) - P.xBar) * (y(level) - P.yBar);    x1 = x1 + w(level) * n(level) * (x(level) - P.xBar) * (x(level) - P.xBar);   end   if x1==0		errorTrap(4);		P.BigB  = 9999999;		if P.noResult==0			P.reportString = 'x1 = 0 in sub-routine "regress".';		P.noResult = 1;	    end   else	    P.BigB = x2/x1;   end   P.varB    = 1/x1;   P.varYBar = 1/nw;return%--------------------------------------------------------------------------------------------------function [out] = NPR(z);   %This is the NPR(z:real):real function from the probit s/w  y = abs(z);  t = 1/(1 + 0.2316419 * y);  p = t * (0.31938153 + t * (-0.356563782 + t * (1.78147794 + t * (-1.82125598 + t * 1.33027443))));  p = 1 - exp(-y * y/2) * p/sqrt(2*pi);        if z < 0, sign = -1;else sign = 1;endout = 0.5 + (p - 0.5) * sign;return%--------------------------------------------------------------------------------------------------function [P] = chiSquare(n_values, ob, ex, P)global chSqTable NOOF_DF dfTable;  exzero = 0;  P.df = n_values - 1;  P.chiSq = 0;  for i = 1:n_values		if ex(i)==0, exzero = 1;		else		P.chiSq = P.chiSq + (((ob(i) - ex(i))*(ob(i) - ex(i)))/ex(i));		end  end	  i = NOOF_DF;  while dfTable(i) > P.df;   i = i - 1;   if i==0,    errorTrap(8);    return   end  end  dfi = i;if exzero==1P.report = 'Chi Sq Illegal: E = 0.';else    if P.chiSq < chSqTable(1,dfi)    P.report  = 'Cannot reject model (p > 0.2).';    else    P.report = 'Model fit is not good (p < 0.2).';   		 if P.chiSq >= chSqTable(2,dfi)    	 P.report = 'Model fit is poor (p < 0.1).';     		if P.chiSq >= chSqTable(3,dfi)      		P.report  = 'Reject model. (p < 0.05)';     			if P.chiSq >= chSqTable(4,dfi)       			P.report = 'Reject model. (p < 0.01)';				end			end		end	endendreturn%--------------------------------------------------------------------------------------------------% function [] = linreg(n_values, x, y, table, f) % %   sserr = 0;%   ssreg = 0;%   ssx = 0;%   ssy = 0;%   ssp = 0;%   x_ = 0;%   y_ = 0;% %    x_ = sum(x)/n_values;%    y_ = sum(y)/n_values;% %   for i = 1:n_values%    dx = x(i) - x_;%    dy = y(i) - y_;%    ssx = ssx + dx * dx;%    ssy = ssy + dy * dy;%    ssp = ssp + dx * dy;%   end%   sx = sqrt(ssx / (n_values - 1));%   r = ssp / sqrt(ssx * ssy);%   r_adj = sqrt(1.0 - (1 - r * r) * (n_values - 1) / (n_values - 2));%   r_sq = r * r * 100;%   r_sq_adj = r_adj * r_adj * 100;%   b = ssp/ssx;%   a = y_ - b * x_;%   for i = 1:n_values%    y_hat(i) = a + b * x(i);%    dy = y(i) - y_hat(i);%    sserr = sserr + dy * dy;%    dy = y_hat(i) - y_;%    ssreg = ssreg + dy * dy;%   end%   sstot = ssreg + sserr;%   dfreg = 1;%   dftot = n_values - 1;%   dferr = n_values - 2;%   mserr = sserr / dferr;%   f_ratio = ssreg / mserr;%   seest = sqrt(mserr);%   seb = seest / (sx * sqrt(n_values - 1));%   tb = b / seb;% %   disp('LINEAR REGRESSION');%   disp('*****************');%   if table==1% %    disp('Pair     X     Y     Yhat');%    disp('------------------------------------------------');%    for i = 1:n_values%     disp(strcat(num2str(i), '     ', num2str(x(i)), '     ',num2str(y(i)), '     ', num2str(y_hat(i))));%    end% %   disp('SUMMARY OF REGRESSION');%   disp('*********************');%   disp(strcat('Y = ', num2str(a), ' + ', num2str(b), ' * X'));%   disp('Source     Coeff     Std Err     t     df');%   disp('------------------------------------------------------------');%   disp(strcat('Intercept : ', num2str(a)));%   disp(strcat('Slope   ', num2str(b), num2str(seb), num2str(tb), num2str(n_values - 2)));%   disp(strcat('Std Error of Estimate: ', num2str(seest)));%   disp(strcat('r                    : ', num2str(r)));%   disp(strcat('r (adjusted)         : ', num2str(r_adj)));%   disp(strcat('r squared (%)        : ', num2str(r_sq)));%   disp(strcat('r squared (adj) (%)  : ', num2str(r_sq_adj)));%   disp('ANOVA SUMMARY TABLE');%   disp('*******************');%   disp('Source      SS      df      MS      F');%   disp('------------------------------------------------------------');%   disp(strcat('Regression',  num2str(ssreg),  num2str(dfreg),  num2str(ssreg),  num2str(f_ratio)));%   disp(strcat('Error',  num2str(sserr),  num2str(dferr),  num2str(mserr)));%   disp(strcat('Total',  num2str(sstot),  num2str(dftot)));%   % end% return%--------------------------------------------------------------------------------------------------function P = doChiSqForProbit(x, n, r, P) [nLevels, ndims]  = size(x);   for i = 1:nLevels    nprArg = P.yBar + P.BigB * (x(i) - P.xBar);    if nprArg > 150, ex(i) = -(P.BigC/(1-P.BigC)); 	elseif nprArg < -150, ex(i) = -(P.BigC/(1-P.BigC)); 	else ex(i)= NPR(nprArg);    ex(i)= (P.BigC + ex(i)*(1-P.BigC))*n(i);	end   end   P = chiSquare(nLevels,r,ex,P);   return%--------------------------------------------------------------------------------------------------function done = plotProbitGraph(npts, x, y, P)%                    %  const%   col        =         clGreen;%   curveCol   =         clRed;% %   minx   = x(1);%   maxx   = x(npts);%   xrange = abs(maxx-minx);% %    RJS_PLOT.createGraphForm;%    RJS_PLOT.setLabels('Stimulus Level','Threshold','Observer Results');%    RJS_PLOT.setRange(trunc(x[1]+0.5),trunc(x[npts]+0.5),3,0,100,10);% % {%    for i := 1 to npts do%    begin%     plotPoint(x[i],y[i],col);%    end;% }% % if not noResult then%    begin%     for i := 1 to NOOF_PROBITPOINTS do%     begin%      curvex[i] := minx + (i-1)*xrange/(NOOF_PROBITPOINTS-1);%      nprArg    := P.yBar + P.BigB * (curvex[i] - P.xBar);% %      if (nprArg > 150) or (nprArg < -150) then curvey[i] := -(P.BigC/(1-P.BigC)) else curvey[i] := NPR(nprArg);% %      curvey[i] := (P.BigC + curvey[i]*(1-P.BigC))*100;%     end;% %     PlotCurvePC(x, y, 1, 1, npts, col);%     PlotCurvePC(curvex, curvey, 1, 1, NOOF_PROBITPOINTS, curveCol);% %     plot50 := 100*(P.BigC + 0.5*(1-P.BigC));%     //plot75 := 100*(P.BigC + 0.75*(1-P.BigC));% %     plotLine(minx,plot50,maxx,plot50,clLtGray,'P50');%     //plotLine(minx,plot75,maxx,plot75,clDkGray,'P75');% % {Plot error Bars}%     plotLine(P50-sep50,plot50-2,P50-sep50,plot50+2,clLtGray,'');%     plotLine(P50+sep50,plot50-2,P50+sep50,plot50+2,clLtGray,'');%     plotLine(P.P50,0,P.P50,100,clLtGray,'');%     for i := 1 to npts do%    begin%     plotPoint(x[i],y[i],col);%    end;% %     end;%{not noResult}% %  {* Actually displays the graph in a window on screen - nothing is displayed% %  until this point *}%   RJS_PLOT.showGraphForm;% %  {* NB. The graphplotting program takes care of freeing the memory used *}%   end %{with probitParams}return%--------------------------------------------------------------------------------------------------